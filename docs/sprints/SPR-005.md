# SPR-005 — Auditoría base (audit_events) + hook para acciones sensibles
**Estado:** BLOQUEADO (no editar; cambios solo por RFC/ADR/CHANGELOG)  
**Stage:** 1 (Core local)  
**Duración objetivo:** 45–90 min  
**Tipo:** Infra/Seguridad (sin features de negocio)

---

## 1) Objetivo (qué se logra)
Dejar auditoría operativa para registrar eventos clave (quién/qué/cuándo/dónde), lista para que en sprints futuros **cualquier acción sensible** quede registrada sin re-trabajo:

- Persistencia estable en DB (`audit_events`).
- Servicio backend `AuditService` para registrar eventos.
- “Hook” reutilizable (AOP/annotation o helper explícito) para que futuros endpoints registren auditoría.
- Registrar al menos:
  - Login exitoso
  - Refresh token exitoso
  - Denegación por permisos (si ya hay un lugar único para hacerlo; si no, RFC)

**Reglas**
- Código en inglés (clases/variables). UI español (si toca UI, aquí no debería).
- Sin Docker.
- Linux-friendly: nombres sin inconsistencias de mayúsculas/minúsculas.

---

## 2) Alcance

### 2.1 INCLUYE (Scope = Sí)
**DB**
- Crear migración incremental para robustecer `audit_events` (no romper lo existente).
- En Postgres usar `ALTER TABLE ... ADD COLUMN IF NOT EXISTS` para evitar fallas si columnas ya existen.

**Backend**
- Implementar:
  - `AuditService` (inserción).
  - `AuditContext` (tenantId, branchId opcional, actor userId/email, request metadata).
  - `RequestMetadataFilter` (captura ip/user-agent y los deja accesibles).
  - Hook listo para ser usado:
    - Opción A (preferida): `@Audited(actionCode="...")` + Aspect.
    - Opción B: helper explícito `auditService.record(...)` (si AOP complica).
- Registrar auditoría mínima en auth flow:
  - `AUTH_LOGIN_SUCCESS`
  - `AUTH_REFRESH_SUCCESS`

**Scripts**
- `scripts/smoke/sprint5.ps1`:
  - hace login (reusando endpoints de SPR-004),
  - llama `/api/me`,
  - imprime info para luego consultar DB.
  - NO consulta DB automáticamente (a menos que ya exista tooling); deja comandos psql a ejecutar.

**Docs**
- LOG/STATUS/CHANGELOG actualizados (sin DONE/APROBADO).

### 2.2 EXCLUYE (Scope = No)
- UI para ver auditoría (va en SPR-025).
- Reportes de auditoría.
- Auditoría “antes/después” completa de entidades de negocio (aún no existen).

---

## 3) Entregables

### 3.1 Migración DB
Agregar un archivo nuevo (ejemplo de nombre; ajustar número según orden real):
- `backend/src/main/resources/db/migration/V__audit_events_columns.sql`

**Requerido:** añadir columnas (si no existen) para soportar auditoría completa:

Campos recomendados (mínimo):
- `tenant_id` (uuid, NOT NULL si ya existe; si no, RFC para estrategia)
- `branch_id` (uuid, NULL)
- `actor_user_id` (uuid, NULL)
- `actor_email` (text, NULL)
- `action_code` (text, NOT NULL)
- `entity_type` (text, NULL)
- `entity_id` (uuid, NULL)
- `summary` (text, NULL)
- `before_state` (jsonb, NULL)
- `after_state` (jsonb, NULL)
- `metadata` (jsonb, NULL)
- `ip_address` (text, NULL)  (inet si quieres, pero evita fricción)
- `user_agent` (text, NULL)
- `created_at` (timestamptz, NOT NULL default now())

Índices mínimos (si no existen):
- `(tenant_id, created_at desc)`
- `(tenant_id, action_code, created_at desc)`

### 3.2 Backend (paquetes sugeridos)
- `com.sisferrete.platform.audit.*` (o equivalente):
  - `AuditService`
  - `AuditRepository` (JdbcTemplate) o directo en service
  - `AuditEvent` (modelo)
  - `Audited` (anotación) + `AuditedAspect` (si aplica)
  - `AuditContextProvider`

### 3.3 Smoke
- `scripts/smoke/sprint5.ps1`

---

## 4) Instrucciones de implementación (cerradas)

### 4.1 DB
- Si `audit_events` ya existe, NO recrearla.
- Solo agregar columnas/índices con `IF NOT EXISTS` cuando aplique.
- Si algo bloquea por incompatibilidad (ej: columna existe con tipo diferente):
  - Crear RFC explicando el problema y NO forzar cambios destructivos.

### 4.2 Servicio de auditoría
- Debe existir una sola forma central de registrar eventos (evitar “insert por todos lados”).
- `AuditService.record(...)` debe aceptar:
  - tenantId (requerido)
  - branchId (opcional)
  - actorUserId/actorEmail (opcional si anon)
  - actionCode (requerido)
  - entityType/entityId (opcionales)
  - summary (opcional)
  - beforeState/afterState (opcionales, json)
  - metadata (opcional)
  - ip/userAgent (si hay request)

### 4.3 Eventos mínimos a registrar (obligatorio)
- En login exitoso: `AUTH_LOGIN_SUCCESS`
- En refresh exitoso: `AUTH_REFRESH_SUCCESS`
> Si login/refresh aún no tienen un punto único claro, crear RFC para ubicar el hook (pero no inventar).

### 4.4 Trazabilidad
- `docs/status/STATUS.md`: SPR-005 -> `READY_FOR_VALIDATION` + commit hash + archivos.
- `docs/log/LOG.md`: append con:
  - comandos exactos
  - sección EVIDENCIA con placeholders (NO outputs inventados).
- `docs/CHANGELOG.md`: `[Unreleased]` + “Audit base + hooks”.

---

## 5) Criterios de aceptación (AC)
- [ ] Migración aplica sin error (Postgres local).
- [ ] `AuditService` registra eventos en DB.
- [ ] Login/refresh generan al menos 2 eventos de auditoría (AUTH_*).
- [ ] Existe `scripts/smoke/sprint5.ps1`.
- [ ] LOG y STATUS actualizados y estado = READY_FOR_VALIDATION.
- [ ] Repo compila.

---

## 6) Smoke test manual (usuario)
### Pasos
1) Levantar Postgres + backend.
2) Ejecutar:
   - `pwsh -ExecutionPolicy Bypass -File .\scripts\smoke\sprint5.ps1`
3) En psql, consultar:
   - `select action_code, created_at from audit_events order by created_at desc limit 10;`

### Evidencia (pegar en LOG.md)
- Output de `sprint5.ps1`
- Resultado del query psql

---

## 7) DoD
- AC completos.
- Estado queda `READY_FOR_VALIDATION` (nunca DONE/APROBADO aquí).

<!-- EOF -->
