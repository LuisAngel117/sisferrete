# SPR-012 — Precios: listas (retail/mayorista), precios por UoM, campañas, motor de precio efectivo + guardrails (no bajo costo/margen)
**Estado:** BLOQUEADO (no editar; cambios solo por RFC/ADR/CHANGELOG)  
**Stage:** 1 (Core local)  
**Duración objetivo:** 45–90 min  
**Tipo:** Pricing (base), listo para integrar a POS/E-commerce luego

---

## 1) Objetivo
Implementar el módulo de pricing completo a nivel administración y cálculo:

- Listas de precios multi-tenant (retail por defecto + mayorista).
- Precios por:
  - producto base
  - variante
  - presentación/empaque (UoM de venta) (si aplica)
- Campañas (descuentos “por campaña”).
- Motor de precio efectivo (API): dado un producto/variante/presentación + lista objetivo + fecha, retorna:
  - precio base
  - campaña aplicada
  - precio final redondeado a centavos
- Guardrail: **no vender bajo costo/margen** (preparado desde ya):
  - costo base manual inicial protegido (hasta que compras/inventario lo actualicen).
  - validación de “floor” y permisos de override.

**Decisiones cerradas**
- Moneda: USD.
- Redondeo: 2 decimales (centavos).
- Costeo global: **Promedio ponderado** (cuando exista inventario).  
  Mientras no exista, el sistema usa **costo base manual inicial** (protegido) como “cost basis”.

---

## 2) Alcance

### 2.1 INCLUYE (Scope = Sí)
**Permisos nuevos (códigos exactos)**
- `PRICING_MANAGE` (gestionar listas/precios/campañas)
- `COST_EDIT` (editar costo base manual inicial)
- `PRICING_SELL_BELOW_FLOOR` (override para permitir precio por debajo del piso)
- `DISCOUNT_MANUAL_OVERRIDE` (preparación para POS; aún no se usa en ventas, pero se deja definido)

> Asignación mínima:
- `ADMIN`: `PRICING_MANAGE`, `COST_EDIT` (si se decide separar por RFC, pero por defecto sí)
- `SUPERADMIN`: todos

**DB**
- `price_lists`
- `price_list_items`
- `pricing_campaigns`
- `pricing_campaign_rules` (scope: category/brand/product/variant)
- `product_cost_basis` (costo base manual inicial, protegido)

**Backend Admin API**
- CRUD listas de precio
- CRUD items (precio por producto/variante/presentación/UoM)
- CRUD campañas + reglas
- Endpoint de cálculo:
  - `POST /api/pricing/quote` (requiere auth; para POS/e-commerce interno)
- Validaciones y redondeo.

**Frontend (mínimo, ES)**
- Admin → Precios:
  - listas de precios
  - items por lista (buscar producto y asignar precio)
- Admin → Campañas:
  - crear campaña con fechas + % descuento + reglas simples
- Admin → Costos:
  - setear costo base manual por producto/variante (protegido)

### 2.2 EXCLUYE (Scope = No)
- POS ventas (aplica guardrail al facturar) → sprint posterior.
- Cliente mayorista con precio por cliente → posterior.
- Pasarela de pago e-commerce → posterior.

---

## 3) Modelo de datos (cerrado)

### 3.1 price_lists
Campos:
- `id uuid pk`
- `tenant_id uuid not null`
- `code text not null` (uppercase snake: RETAIL, WHOLESALE)
- `name text not null` (ES visible)
- `is_default boolean not null default false`
- `is_active boolean not null default true`
- timestamps

Constraints:
- unique `(tenant_id, code)`
- solo una default por tenant (si DB constraint es complejo, enforce en app + RFC para hard constraint)

### 3.2 price_list_items
Representa el precio “base” sin campaña.

Campos:
- `id uuid pk`
- `tenant_id uuid not null`
- `price_list_id uuid not null`
- `product_id uuid not null`
- `variant_id uuid null`
- `packaging_id uuid null` (si el precio es por presentación)
- `sale_uom_id uuid not null` (UoM en la que se vende el item de precio)
- `unit_price numeric(18,2) not null`
- `min_margin_bps int null` (piso por margen, opcional: ej 1500 = 15.00%)
- `is_active boolean not null default true`
- timestamps

Reglas:
- Uno y solo uno de estos escenarios por item:
  1) precio por producto (variant_id null, packaging_id null)
  2) precio por variante (variant_id not null, packaging_id null)
  3) precio por presentación (packaging_id not null) (variant opcional si packaging pertenece a variante)

Unicidad recomendada:
- unique `(tenant_id, price_list_id, product_id, coalesce(variant_id,'0000'), coalesce(packaging_id,'0000'), sale_uom_id)`

### 3.3 product_cost_basis
Costo base manual inicial (hasta que compras actualice):
- `id uuid pk`
- `tenant_id uuid not null`
- `product_id uuid not null`
- `variant_id uuid null`
- `base_uom_id uuid not null`
- `cost_per_base_unit numeric(18,6) not null`
- `updated_at timestamptz not null default now()`

Unicidad:
- `(tenant_id, product_id, variant_id)` unique

Permiso:
- Solo `COST_EDIT` puede modificar.

### 3.4 pricing_campaigns
- `id uuid pk`
- `tenant_id uuid not null`
- `code text not null` (uppercase snake)
- `name text not null` (ES)
- `starts_at timestamptz not null`
- `ends_at timestamptz not null`
- `discount_type text not null` (PERCENT | FIXED)
- `discount_value numeric(18,2) not null` (si PERCENT: 0..100; si FIXED: USD)
- `is_active boolean not null default true`
- timestamps

### 3.5 pricing_campaign_rules
Reglas de alcance (mínimo):
- `id uuid pk`
- `tenant_id uuid not null`
- `campaign_id uuid not null`
- `scope_type text not null` (CATEGORY | BRAND | PRODUCT | VARIANT)
- `scope_id uuid not null`
- `priority int not null default 100` (menor = mayor prioridad)
- `is_active boolean not null default true`

---

## 4) Motor de precio efectivo (cerrado)

### 4.1 Endpoint
`POST /api/pricing/quote`

Request:
- `priceListCode` (string, requerido; ej RETAIL)
- `productId` (uuid, requerido)
- `variantId` (uuid, opcional)
- `packagingId` (uuid, opcional)
- `saleUomId` (uuid, requerido)
- `quantity` (number, requerido)
- `at` (ISO datetime opcional; default now)
- `requestedUnitPrice` (number opcional; para futuro POS manual override — aquí solo se devuelve comparación, no se persiste)

Response:
- `currency` "USD"
- `priceListCode`
- `baseUnitPrice`
- `campaignApplied` (boolean)
- `campaignCode` (nullable)
- `discountAmount`
- `finalUnitPrice`
- `finalLineTotal`
- `rounding` "2dp"
- `floor`:
  - `costBasisPerSaleUnit` (nullable)
  - `minAllowedUnitPrice` (nullable)
  - `canSellBelowFloor` (boolean, depende permiso PRICING_SELL_BELOW_FLOOR)
  - `wouldBlockIfBelowFloor` (boolean) (para POS futuro)
- `notes` (string[])

### 4.2 Cálculo
1) Buscar `price_list_item` más específico:
   - packagingId match
   - luego variantId match
   - luego producto base
2) Determinar campaña aplicable (si está activa y dentro de fecha):
   - prioridad por rule.priority (menor primero)
3) Aplicar descuento:
   - PERCENT: `unitPrice * (pct/100)`
   - FIXED: resta fija por unidad (no bajar de 0)
4) Redondear a 2 decimales.
5) Calcular piso (floor):
   - Obtener cost basis (si existe) por producto/variante
   - Convertir costo base a costo por saleUom:
     - si saleUom == baseUom: 1:1
     - si hay packaging para esa venta: multiplicar por `base_units_per_sale_unit`
     - si no hay conversión: costBasisPerSaleUnit = null
   - minAllowedUnitPrice = costBasisPerSaleUnit * (1 + minMarginBps/10000) si minMarginBps != null
   - si no hay minMarginBps, usar default del sistema: 0 (sin margen) por ahora
6) NO bloquear venta aquí (porque POS aún no existe):
   - solo devolver flags `wouldBlockIfBelowFloor` para integración posterior.

---

## 5) Reglas de permisos (cerradas)
- Admin endpoints de pricing requieren `PRICING_MANAGE`.
- Editar costos requiere `COST_EDIT`.
- El motor quote requiere auth (cualquier usuario logueado) y respeta tenant scope.
- `PRICING_SELL_BELOW_FLOOR` solo afecta flags/behaviour en POS futuro; aquí se informa.

---

## 6) Entregables

### 6.1 Migración DB
Crear migración nueva:
- `backend/src/main/resources/db/migration/V__pricing_base.sql`

Debe:
- crear tablas
- insertar permisos nuevos si no existen
- asignar permisos a roles base (ADMIN, SUPERADMIN) idempotente
- insertar listas base:
  - RETAIL default=true
  - WHOLESALE default=false

### 6.2 Backend
Paquetes sugeridos:
- `com.sisferrete.pricing.*`
  - Admin controllers
  - `PricingQuoteService`
  - repos
  - DTOs

Auditoría obligatoria (usar `AuditService`):
- `PRICING_LIST_CREATED/UPDATED`
- `PRICING_ITEM_CREATED/UPDATED`
- `PRICING_CAMPAIGN_CREATED/UPDATED`
- `COST_BASIS_CHANGED`

### 6.3 Frontend
- `/admin/precios/listas`
- `/admin/precios/items`
- `/admin/precios/campanas`
- `/admin/costos` (solo visible a quien tenga COST_EDIT)

---

## 7) Criterios de aceptación (AC)
- [ ] Migración aplica sin error.
- [ ] CRUD listas y items funciona y requiere `PRICING_MANAGE`.
- [ ] CRUD campañas funciona y requiere `PRICING_MANAGE`.
- [ ] Costo base manual se guarda/consulta y requiere `COST_EDIT`.
- [ ] `POST /api/pricing/quote`:
  - devuelve precio base
  - aplica campaña en rango de fechas
  - redondea 2 decimales
  - devuelve info de floor si hay cost basis
- [ ] Auditoría registra eventos PRICING_* y COST_BASIS_CHANGED.
- [ ] UI mínima en español operable.
- [ ] LOG/STATUS listos (READY_FOR_VALIDATION).
- [ ] Repo compila.

---

## 8) Smoke test manual (usuario)
### Pasos
1) Backend arriba.
2) Crear producto + (opcional) variante + (opcional) presentación.
3) Crear lista RETAIL (o usar default) y asignar price_list_item.
4) Crear campaña 10% para ese producto (rule PRODUCT).
5) Setear costo base manual (con usuario con COST_EDIT).
6) Llamar `POST /api/pricing/quote` y verificar:
   - campaignApplied true
   - finalUnitPrice con 2 decimales
   - floor presente si hay conversion válida

### Evidencia (LOG.md)
- requests/responses (curl) o output de script

---

## 9) DoD
- AC completos.
- Estado: READY_FOR_VALIDATION.

<!-- EOF -->
